\section{Demers Cartogram with Rivers}
 {
  \begin{figure*}[tb!]
      \centering
      \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{figure/flowchart.png}
      \caption{An overview of our hybrid layout algorithm incorporating rivers. See also \Cref{alg:UpdateLayout} in \Cref{sec:{Demers Cartogram with Rivers}} for more detail. % See \Cref{fig:flowchart-stalemate} for the logic of processing a stalemate.
       For illustration purposes, we show the rendered views alongside the logical views representing the actual computation.}
      \label{fig:flowchart}
  \end{figure*}
 }

 {
  \begin{figure}[tb!]
      \centering
      \includegraphics[width=0.7\columnwidth,keepaspectratio]{figure/river_resolution.png}
      \caption{The resolution of rivers can be dynamically adjusted by the user. (A) shows River Thames at its original resolution with 10,170 edges. (B) shows the river at a reduced resolution of 49 edges. We further smooth the river by removing 19 vertices in dense areas, as shown in (C). The reduced resolution preserves the majority of River Thames' original shape and improves the performance of our river intersection tests.}
      \label{fig:river resolution}
  \end{figure}
 }

\Cref{alg:UpdateLayout} and \Cref{fig:flowchart} provide an overview of the hybrid cartogram layout process that includes rivers.

\bobgraph{Initialization with Rivers:} We first load and (optionally) render the CCG geospatial boundaries. For each CCG we compute the centroid and represent it using a square node, $ \node $, with the initial size, $ \nodeSize $ =1 pixel. We then load the river shapefiles and render the rivers. Since the vertices of the river in the shapefiles are not in sequential order, we first render the starting vertex, followed by the next nearest vertex. We do not need the original river resolution to incorporate them into cartograms. We reduce their resolution to match that of the cartogram nodes in order to facilitate node-river intersection tests. This rendering approach enables us to adjust the river resolution as shown in \Cref{fig:river resolution}. We further apply simplification by removing vertices that are too close to each other. The initialization procedure is a one-time process that can be saved for re-use.


\bobgraph{Node Layout and Overlap Removal:} We first apply the Fast Node Overlap Removal (FNOR) algorithm that solves the Variable Placement with Separation Constraints (VPSC) problem \cite{dwyer2006Fast} in order to remove overlap between square nodes. We chose FNOR over other node overlap removal algorithms because FNOR is able to provide spread minimization and node movement minimization while maintaining a good level of global shape preservation \cite{chen2020Node}. Initialized with a pixel size of unity, we gradually increase the node size by one unit at a time to ensure smooth transitions. An increase in $ \nodeSize $ can cause the nodes to overlap. During overlap removal, we compute node trajectories (See \Cref{alg:TranslateNode}) and translate nodes to their new position. Nodes that cross a river, denoted $ \NxR $, are translated back to their previous position. If a node oscillates across a river, we identify this as a stalemate. One iteration of the layout ends when 1) no node overlap is present; 2) no nodes cross a river. We then increase $ \nodeSize $ by one unit and repeat the algorithm until the average cartographic error, $ \nodeCartographicError $, a measure set by the user, reaches its maximum value $ \nodeCartographicErrorMax $. The gradual size increase process provides stability to the layout, as can be seen in the accompanying video.

\subsection{River Intersection Testing}

The logic for translating a node's position is detailed in \Cref{alg:TranslateNode}. When a node's position changes, we test if the node's trajectory intersects any segment of a river. See \Cref{alg:check river intersection}. A bounding box intersection test between the edge defined by node translation and river edges can be performed to reduce the number of edge intersection tests required. Using the intersection test, we identify all nodes that cross the river as a result of the initial FNOR algorithm. We label these nodes, $ \NxR $.

\subsection{Translating Rivers}

For all nodes $ \NxR $ that cross a river, $ \river $, we compute an average vector $ \vectorAvg $ used to translate $ \river $. Whenever a node, $ \node $, crosses a river, we store a vector $ \nodeVectorNNn $ that points in the direction of the translation. We then use a heuristic to translate $ \river $ using the average vector of node intersection $$ \vectorAvg = \sum_{i=1}^{\nodeTopologicalError} \frac{\Vector{\node_i\node_{i_t}}}{\nodeTopologicalError} $$, where $ \nodeTopologicalError $ is the number of nodes intersecting the river. This step intends to create space for the next iteration of node translation without crossing a river. The detailed procedure for translating rivers is provided by \Cref{alg:TranslateRiver}.


When a river, $ \river $, is translated by $ \vectorAvg $, this can trigger a scenario where the nodes are crossed by a translated river, denoted $ \RxN $. As a heuristic we also translate these nodes by $ \vectorAvg $. The reasoning behind this is that $ \vectorAvg $ indicates which direction the river needs to be translated in order to create space for nodes that are too crowded together. In practice, $ \vectorAvg $ is multiplied by a scaling factor $ \propto\vectorAvg $. Thus, we can influence how far $ \river $ is translated in each iteration of the layout algorithm. We can use this to ensure smooth transitions between iterations.

\subsection{Process Stalemates}

As the FNOR always attempts to produce an optimal node layout where node distribution and translation are minimized, a node's translation path can repeatedly intersect a river due to congestion, creating a stalemate situation, as shown in \Cref{fig:stalemate}. If a node is translated between two positions, $ \node $ and $ \nodeFNOR $, for $ \stalemateMax $ iterations (a user-adjustable parameter), we introduce a heuristic solution: constructing a corridor to alleviate the congestion. A corridor, $ \Corridor $, is a rectangle with a width of $ \CorridorWidth $ and a length of $ \CorridorLength $, formed by deriving two edges $ \EdgeParallelA $ and $ \EdgeParallelB $ such that $ \EdgeParallelA \parallel \EdgeParallelA \parallel \nodeLineNtNc $ (See \Cref{fig:corridor}C and D). All nodes enclosed by $ \Corridor $ are then translated by $ \nodeVectorTC $ to alleviate the congestion (See \Cref{fig:corridor}E). The procedure for constructing corridors is provided by \Cref{alg:derive corridor}.

% {
%     \begin{figure}[tb!]
%         \centering
%         \includegraphics[width=\columnwidth,keepaspectratio]{figure/flowchart stalemate.png}
%         \caption{A flowchart illustration of stalemate processing. See \Cref{subsec:{Process Stalemates}}, \Cref{fig:stalemate}, and \Cref{fig:corridor} for more detail.}
%         \label{fig:flowchart-stalemate}
%     \end{figure}
%    }
   
    {
        \begin{figure}[tb!]
            \centering
            \includegraphics[width=\columnwidth,keepaspectratio]{figure/stalemate.png}
            \caption{A stalemate: when a node's translation path $ \nodeVectorCT $ (iteration 1) intersects a river $ \stalemateMax $ times. The node is translated back to its previous position (iteration 2). A stalemate can occur when the area is congested and the node is unable to translate to a new position without intersecting a river.}
            \label{fig:stalemate}
        \end{figure}
    }

    {
        \begin{figure}[tb!]
            \centering
            \includegraphics[width=\columnwidth,keepaspectratio]{figure/corridor.png}
            \caption{A stalemate occurs when a node's translation path $ \nodeVectorCT $ intersects a river for $ \stalemateMax $ times, as shown in (A). To address this, we derive a corridor (orange rectangle in (E)) based on $ \node $ and $ \nodeFNOR $. All nodes within the corridor are translated based on $ \nodeVectorTC $, such that $ \nodeVectorNNn = \nodeVectorNinNinn $. For clarity in the illustration, we place nodes sparsely in this figure.}
            \label{fig:corridor}
        \end{figure}
    }


\subsection{Terminating the Algorithm}

The algorithm terminates when $ \nodeCartographicError $ reaches $ \nodeCartographicErrorMax $, the error tolerance set by the user. We adopt the maximum cartographic error from \citea{alam2015Quantitative}, namely: $$ \nodeCartographicErrorMax = \max _{\node \in \nodeList} \frac{|\node_i-\node_{i_t}|}{\max \{\node_i, \node_{i_t}\}}
$$

where $ \node_i $ and $ \node_{i_t} $ are the initial and translated regions in the cartogram, $ \nodeList $ represent the list of regions, and $ \nodeCartographicErrorMax $ is a normalized value that we express as a percentage.
Because the algorithm processes node-river intersections, we can measure a novel kind of error, namely, topological error $ \nodeTopologicalError $. We maintain $ \nodeTopologicalError = 0 $, however, we can count how many nodes would have crossed a river if we did not test for this and simply let nodes cross rivers. We express $ \nodeTopologicalError $ in the normalized range $ \nodeTopologicalError \in [0,1] $, where $ \nodeTopologicalErrorMax $ is the case where all nodes cross a river.

When the algorithm terminates, the node layout is considered optimal where no node has crossed, or crossed by a river (denoted by $ \nodeTopologicalError $ = 0 and $ \nodeCartographicError < \nodeCartographicErrorMax $). Every node remains on the same side of the river as its centroid.

\subsection{User Options}

\Cref{fig:overview} presents an overview of the application, including the user options. The user can adjust the following parameters:

\bobgraph{Rendering Visibility:} The rendering visibility of various elements, including the choropleth shapefile, rivers, nodes, and node centroids, can be toggled on and off.

\bobgraph{Node Mapping:} Both size and color of the nodes can be mapped to different EHR attributes or set to uniform.

\bobgraph{Overlap Removal Speed:} The overlap removal process can be observed in a step-by-step manner, or the algorithm can be run automatically. 

\bobgraph{Maximum Cartographic Error:} The user can adjust the maximum cartographic error, $ \nodeCartographicErrorMax $, which is used to terminate the algorithm.

\bobgraph{River Translation:} The behavior of rivers during the process can also be adjusted by the user: 1) Enable river crossing: this option allows nodes to cross rivers. Nodes cannot cross rivers by default; 2) Disable river translation: this option disables the translation of rivers, rivers are translated by default. Both options are useful for generating different layouts and for observing the behavior of the hybrid layout algorithm.

\bobgraph{Corridor Length:} The user can define the length of a corridor, which is used to resolve stalemate situations. A longer corridor length allows more nodes to be translated when a stalemate occurs, but may result in a less accurate layout. The default corridor length is three times the max node size.

\bobgraph{River Thickness and Resolution:} Increasing the thickness of rivers may improve the recognizability of the cartogram. Similarity, increasing the resolution of rivers, at the expense of the speed of node-river intersection test, may produce a layout with higher legibility.

{
\begin{figure*}[tb!]
    \centering
    \includegraphics[width=0.7\textwidth,keepaspectratio]{figure/UI.png}
    \caption{A screenshot of the user interface. User options are provided to adjust the terminating conditions (size and error), color mapping, visibility of nodes and rivers. Other options include the ability to control the overlap removal behavior: rivers can be static or dynamic. See \Cref{subsec:{User Options}} for more on user options. In this figure, $ \nodeCartographicErrorMax $ = 1.875\%, and an $ \nodeTopologicalError $ of 9.63\% is eliminated.}
    \label{fig:overview}
\end{figure*}
}